{-# LANGUAGE TypeApplications #-}


-- | Copyright  : Will Thompson, Iñaki García Etxebarria and Jonas Platte
-- License    : LGPL-2.1
-- Maintainer : Iñaki García Etxebarria
-- 
-- t'GI.Gtk.Objects.IMContext.IMContext' defines the interface for GTK+ input methods. An input method
-- is used by GTK+ text input widgets like t'GI.Gtk.Objects.Entry.Entry' to map from key events to
-- Unicode character strings.
-- 
-- The default input method can be set programmatically via the
-- t'GI.Gtk.Objects.Settings.Settings':@/gtk-im-module/@ GtkSettings property. Alternatively, you may set
-- the GTK_IM_MODULE environment variable as documented in
-- [Running GTK+ Applications][gtk-running].
-- 
-- The t'GI.Gtk.Objects.Entry.Entry' t'GI.Gtk.Objects.Entry.Entry':@/im-module/@ and t'GI.Gtk.Objects.TextView.TextView' t'GI.Gtk.Objects.TextView.TextView':@/im-module/@
-- properties may also be used to set input methods for specific widget
-- instances. For instance, a certain entry widget might be expected to contain
-- certain characters which would be easier to input with a certain input
-- method.
-- 
-- An input method may consume multiple key events in sequence and finally
-- output the composed result. This is called preediting, and an input method
-- may provide feedback about this process by displaying the intermediate
-- composition states as preedit text. For instance, the default GTK+ input
-- method implements the input of arbitrary Unicode code points by holding down
-- the Control and Shift keys and then typing “U” followed by the hexadecimal
-- digits of the code point.  When releasing the Control and Shift keys,
-- preediting ends and the character is inserted as text. Ctrl+Shift+u20AC for
-- example results in the € sign.
-- 
-- Additional input methods can be made available for use by GTK+ widgets as
-- loadable modules. An input method module is a small shared library which
-- implements a subclass of t'GI.Gtk.Objects.IMContext.IMContext' or t'GI.Gtk.Objects.IMContextSimple.IMContextSimple' and exports
-- these four functions:
-- 
-- 
-- === /C code/
-- >
-- >void im_module_init(GTypeModule *module);
-- 
-- This function should register the t'GType' of the t'GI.Gtk.Objects.IMContext.IMContext' subclass which
-- implements the input method by means of 'GI.GObject.Objects.TypeModule.typeModuleRegisterType'. Note
-- that 'GI.GObject.Functions.typeRegisterStatic' cannot be used as the type needs to be
-- registered dynamically.
-- 
-- 
-- === /C code/
-- >
-- >void im_module_exit(void);
-- 
-- Here goes any cleanup code your input method might require on module unload.
-- 
-- 
-- === /C code/
-- >
-- >void im_module_list(const GtkIMContextInfo ***contexts, int *n_contexts)
-- >{
-- >  *contexts = info_list;
-- >  *n_contexts = G_N_ELEMENTS (info_list);
-- >}
-- 
-- This function returns the list of input methods provided by the module. The
-- example implementation above shows a common solution and simply returns a
-- pointer to statically defined array of t'GI.Gtk.Structs.IMContextInfo.IMContextInfo' items for each
-- provided input method.
-- 
-- 
-- === /C code/
-- >
-- >GtkIMContext * im_module_create(const gchar *context_id);
-- 
-- This function should return a pointer to a newly created instance of the
-- t'GI.Gtk.Objects.IMContext.IMContext' subclass identified by /@contextId@/. The context ID is the same
-- as specified in the t'GI.Gtk.Structs.IMContextInfo.IMContextInfo' array returned by @/im_module_list()/@.
-- 
-- After a new loadable input method module has been installed on the system,
-- the configuration file @gtk.immodules@ needs to be
-- regenerated by [gtk-query-immodules-3.0][gtk-query-immodules-3.0],
-- in order for the new input method to become available to GTK+ applications.

#if (MIN_VERSION_haskell_gi_overloading(1,0,0) && !defined(__HADDOCK_VERSION__))
#define ENABLE_OVERLOADING
#endif

module GI.Gtk.Objects.IMContext
    ( 

-- * Exported types
    IMContext(..)                           ,
    IsIMContext                             ,
    toIMContext                             ,
    noIMContext                             ,


 -- * Methods
-- ** Overloaded methods #method:Overloaded methods#

#if defined(ENABLE_OVERLOADING)
    ResolveIMContextMethod                  ,
#endif


-- ** deleteSurrounding #method:deleteSurrounding#

#if defined(ENABLE_OVERLOADING)
    IMContextDeleteSurroundingMethodInfo    ,
#endif
    iMContextDeleteSurrounding              ,


-- ** filterKeypress #method:filterKeypress#

#if defined(ENABLE_OVERLOADING)
    IMContextFilterKeypressMethodInfo       ,
#endif
    iMContextFilterKeypress                 ,


-- ** focusIn #method:focusIn#

#if defined(ENABLE_OVERLOADING)
    IMContextFocusInMethodInfo              ,
#endif
    iMContextFocusIn                        ,


-- ** focusOut #method:focusOut#

#if defined(ENABLE_OVERLOADING)
    IMContextFocusOutMethodInfo             ,
#endif
    iMContextFocusOut                       ,


-- ** getPreeditString #method:getPreeditString#

#if defined(ENABLE_OVERLOADING)
    IMContextGetPreeditStringMethodInfo     ,
#endif
    iMContextGetPreeditString               ,


-- ** getSurrounding #method:getSurrounding#

#if defined(ENABLE_OVERLOADING)
    IMContextGetSurroundingMethodInfo       ,
#endif
    iMContextGetSurrounding                 ,


-- ** reset #method:reset#

#if defined(ENABLE_OVERLOADING)
    IMContextResetMethodInfo                ,
#endif
    iMContextReset                          ,


-- ** setClientWindow #method:setClientWindow#

#if defined(ENABLE_OVERLOADING)
    IMContextSetClientWindowMethodInfo      ,
#endif
    iMContextSetClientWindow                ,


-- ** setCursorLocation #method:setCursorLocation#

#if defined(ENABLE_OVERLOADING)
    IMContextSetCursorLocationMethodInfo    ,
#endif
    iMContextSetCursorLocation              ,


-- ** setSurrounding #method:setSurrounding#

#if defined(ENABLE_OVERLOADING)
    IMContextSetSurroundingMethodInfo       ,
#endif
    iMContextSetSurrounding                 ,


-- ** setUsePreedit #method:setUsePreedit#

#if defined(ENABLE_OVERLOADING)
    IMContextSetUsePreeditMethodInfo        ,
#endif
    iMContextSetUsePreedit                  ,




 -- * Properties
-- ** inputHints #attr:inputHints#
-- | /No description available in the introspection data./

#if defined(ENABLE_OVERLOADING)
    IMContextInputHintsPropertyInfo         ,
#endif
    constructIMContextInputHints            ,
    getIMContextInputHints                  ,
#if defined(ENABLE_OVERLOADING)
    iMContextInputHints                     ,
#endif
    setIMContextInputHints                  ,


-- ** inputPurpose #attr:inputPurpose#
-- | /No description available in the introspection data./

#if defined(ENABLE_OVERLOADING)
    IMContextInputPurposePropertyInfo       ,
#endif
    constructIMContextInputPurpose          ,
    getIMContextInputPurpose                ,
#if defined(ENABLE_OVERLOADING)
    iMContextInputPurpose                   ,
#endif
    setIMContextInputPurpose                ,




 -- * Signals
-- ** commit #signal:commit#

    C_IMContextCommitCallback               ,
    IMContextCommitCallback                 ,
#if defined(ENABLE_OVERLOADING)
    IMContextCommitSignalInfo               ,
#endif
    afterIMContextCommit                    ,
    genClosure_IMContextCommit              ,
    mk_IMContextCommitCallback              ,
    noIMContextCommitCallback               ,
    onIMContextCommit                       ,
    wrap_IMContextCommitCallback            ,


-- ** deleteSurrounding #signal:deleteSurrounding#

    C_IMContextDeleteSurroundingCallback    ,
    IMContextDeleteSurroundingCallback      ,
#if defined(ENABLE_OVERLOADING)
    IMContextDeleteSurroundingSignalInfo    ,
#endif
    afterIMContextDeleteSurrounding         ,
    genClosure_IMContextDeleteSurrounding   ,
    mk_IMContextDeleteSurroundingCallback   ,
    noIMContextDeleteSurroundingCallback    ,
    onIMContextDeleteSurrounding            ,
    wrap_IMContextDeleteSurroundingCallback ,


-- ** preeditChanged #signal:preeditChanged#

    C_IMContextPreeditChangedCallback       ,
    IMContextPreeditChangedCallback         ,
#if defined(ENABLE_OVERLOADING)
    IMContextPreeditChangedSignalInfo       ,
#endif
    afterIMContextPreeditChanged            ,
    genClosure_IMContextPreeditChanged      ,
    mk_IMContextPreeditChangedCallback      ,
    noIMContextPreeditChangedCallback       ,
    onIMContextPreeditChanged               ,
    wrap_IMContextPreeditChangedCallback    ,


-- ** preeditEnd #signal:preeditEnd#

    C_IMContextPreeditEndCallback           ,
    IMContextPreeditEndCallback             ,
#if defined(ENABLE_OVERLOADING)
    IMContextPreeditEndSignalInfo           ,
#endif
    afterIMContextPreeditEnd                ,
    genClosure_IMContextPreeditEnd          ,
    mk_IMContextPreeditEndCallback          ,
    noIMContextPreeditEndCallback           ,
    onIMContextPreeditEnd                   ,
    wrap_IMContextPreeditEndCallback        ,


-- ** preeditStart #signal:preeditStart#

    C_IMContextPreeditStartCallback         ,
    IMContextPreeditStartCallback           ,
#if defined(ENABLE_OVERLOADING)
    IMContextPreeditStartSignalInfo         ,
#endif
    afterIMContextPreeditStart              ,
    genClosure_IMContextPreeditStart        ,
    mk_IMContextPreeditStartCallback        ,
    noIMContextPreeditStartCallback         ,
    onIMContextPreeditStart                 ,
    wrap_IMContextPreeditStartCallback      ,


-- ** retrieveSurrounding #signal:retrieveSurrounding#

    C_IMContextRetrieveSurroundingCallback  ,
    IMContextRetrieveSurroundingCallback    ,
#if defined(ENABLE_OVERLOADING)
    IMContextRetrieveSurroundingSignalInfo  ,
#endif
    afterIMContextRetrieveSurrounding       ,
    genClosure_IMContextRetrieveSurrounding ,
    mk_IMContextRetrieveSurroundingCallback ,
    noIMContextRetrieveSurroundingCallback  ,
    onIMContextRetrieveSurrounding          ,
    wrap_IMContextRetrieveSurroundingCallback,




    ) where

import Data.GI.Base.ShortPrelude
import qualified Data.GI.Base.ShortPrelude as SP
import qualified Data.GI.Base.Overloading as O
import qualified Prelude as P

import qualified Data.GI.Base.Attributes as GI.Attributes
import qualified Data.GI.Base.ManagedPtr as B.ManagedPtr
import qualified Data.GI.Base.GClosure as B.GClosure
import qualified Data.GI.Base.GError as B.GError
import qualified Data.GI.Base.GVariant as B.GVariant
import qualified Data.GI.Base.GValue as B.GValue
import qualified Data.GI.Base.GParamSpec as B.GParamSpec
import qualified Data.GI.Base.CallStack as B.CallStack
import qualified Data.GI.Base.Properties as B.Properties
import qualified Data.GI.Base.Signals as B.Signals
import qualified Data.Text as T
import qualified Data.ByteString.Char8 as B
import qualified Data.Map as Map
import qualified Foreign.Ptr as FP
import qualified GHC.OverloadedLabels as OL

import qualified GI.GObject.Objects.Object as GObject.Object
import qualified GI.Gdk.Objects.Window as Gdk.Window
import qualified GI.Gdk.Structs.EventKey as Gdk.EventKey
import qualified GI.Gdk.Structs.Rectangle as Gdk.Rectangle
import {-# SOURCE #-} qualified GI.Gtk.Enums as Gtk.Enums
import {-# SOURCE #-} qualified GI.Gtk.Flags as Gtk.Flags
import qualified GI.Pango.Structs.AttrList as Pango.AttrList

-- | Memory-managed wrapper type.
newtype IMContext = IMContext (ManagedPtr IMContext)
    deriving (Eq)
foreign import ccall "gtk_im_context_get_type"
    c_gtk_im_context_get_type :: IO GType

instance GObject IMContext where
    gobjectType = c_gtk_im_context_get_type
    

-- | Convert 'IMContext' to and from 'Data.GI.Base.GValue.GValue' with 'Data.GI.Base.GValue.toGValue' and 'Data.GI.Base.GValue.fromGValue'.
instance B.GValue.IsGValue IMContext where
    toGValue o = do
        gtype <- c_gtk_im_context_get_type
        B.ManagedPtr.withManagedPtr o (B.GValue.buildGValue gtype B.GValue.set_object)
        
    fromGValue gv = do
        ptr <- B.GValue.get_object gv :: IO (Ptr IMContext)
        B.ManagedPtr.newObject IMContext ptr
        
    

-- | Type class for types which can be safely cast to `IMContext`, for instance with `toIMContext`.
class (GObject o, O.IsDescendantOf IMContext o) => IsIMContext o
instance (GObject o, O.IsDescendantOf IMContext o) => IsIMContext o

instance O.HasParentTypes IMContext
type instance O.ParentTypes IMContext = '[GObject.Object.Object]

-- | Cast to `IMContext`, for types for which this is known to be safe. For general casts, use `Data.GI.Base.ManagedPtr.castTo`.
toIMContext :: (MonadIO m, IsIMContext o) => o -> m IMContext
toIMContext = liftIO . unsafeCastTo IMContext

-- | A convenience alias for `Nothing` :: `Maybe` `IMContext`.
noIMContext :: Maybe IMContext
noIMContext = Nothing

#if defined(ENABLE_OVERLOADING)
type family ResolveIMContextMethod (t :: Symbol) (o :: *) :: * where
    ResolveIMContextMethod "bindProperty" o = GObject.Object.ObjectBindPropertyMethodInfo
    ResolveIMContextMethod "bindPropertyFull" o = GObject.Object.ObjectBindPropertyFullMethodInfo
    ResolveIMContextMethod "deleteSurrounding" o = IMContextDeleteSurroundingMethodInfo
    ResolveIMContextMethod "filterKeypress" o = IMContextFilterKeypressMethodInfo
    ResolveIMContextMethod "focusIn" o = IMContextFocusInMethodInfo
    ResolveIMContextMethod "focusOut" o = IMContextFocusOutMethodInfo
    ResolveIMContextMethod "forceFloating" o = GObject.Object.ObjectForceFloatingMethodInfo
    ResolveIMContextMethod "freezeNotify" o = GObject.Object.ObjectFreezeNotifyMethodInfo
    ResolveIMContextMethod "getv" o = GObject.Object.ObjectGetvMethodInfo
    ResolveIMContextMethod "isFloating" o = GObject.Object.ObjectIsFloatingMethodInfo
    ResolveIMContextMethod "notify" o = GObject.Object.ObjectNotifyMethodInfo
    ResolveIMContextMethod "notifyByPspec" o = GObject.Object.ObjectNotifyByPspecMethodInfo
    ResolveIMContextMethod "ref" o = GObject.Object.ObjectRefMethodInfo
    ResolveIMContextMethod "refSink" o = GObject.Object.ObjectRefSinkMethodInfo
    ResolveIMContextMethod "reset" o = IMContextResetMethodInfo
    ResolveIMContextMethod "runDispose" o = GObject.Object.ObjectRunDisposeMethodInfo
    ResolveIMContextMethod "stealData" o = GObject.Object.ObjectStealDataMethodInfo
    ResolveIMContextMethod "stealQdata" o = GObject.Object.ObjectStealQdataMethodInfo
    ResolveIMContextMethod "thawNotify" o = GObject.Object.ObjectThawNotifyMethodInfo
    ResolveIMContextMethod "unref" o = GObject.Object.ObjectUnrefMethodInfo
    ResolveIMContextMethod "watchClosure" o = GObject.Object.ObjectWatchClosureMethodInfo
    ResolveIMContextMethod "getData" o = GObject.Object.ObjectGetDataMethodInfo
    ResolveIMContextMethod "getPreeditString" o = IMContextGetPreeditStringMethodInfo
    ResolveIMContextMethod "getProperty" o = GObject.Object.ObjectGetPropertyMethodInfo
    ResolveIMContextMethod "getQdata" o = GObject.Object.ObjectGetQdataMethodInfo
    ResolveIMContextMethod "getSurrounding" o = IMContextGetSurroundingMethodInfo
    ResolveIMContextMethod "setClientWindow" o = IMContextSetClientWindowMethodInfo
    ResolveIMContextMethod "setCursorLocation" o = IMContextSetCursorLocationMethodInfo
    ResolveIMContextMethod "setData" o = GObject.Object.ObjectSetDataMethodInfo
    ResolveIMContextMethod "setDataFull" o = GObject.Object.ObjectSetDataFullMethodInfo
    ResolveIMContextMethod "setProperty" o = GObject.Object.ObjectSetPropertyMethodInfo
    ResolveIMContextMethod "setSurrounding" o = IMContextSetSurroundingMethodInfo
    ResolveIMContextMethod "setUsePreedit" o = IMContextSetUsePreeditMethodInfo
    ResolveIMContextMethod l o = O.MethodResolutionFailed l o

instance (info ~ ResolveIMContextMethod t IMContext, O.MethodInfo info IMContext p) => OL.IsLabel t (IMContext -> p) where
#if MIN_VERSION_base(4,10,0)
    fromLabel = O.overloadedMethod @info
#else
    fromLabel _ = O.overloadedMethod @info
#endif

#endif

-- signal IMContext::commit
-- | The [commit](#signal:commit) signal is emitted when a complete input sequence
-- has been entered by the user. This can be a single character
-- immediately after a key press or the final result of preediting.
type IMContextCommitCallback =
    T.Text
    -- ^ /@str@/: the completed character(s) entered by the user
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `IMContextCommitCallback`@.
noIMContextCommitCallback :: Maybe IMContextCommitCallback
noIMContextCommitCallback = Nothing

-- | Type for the callback on the (unwrapped) C side.
type C_IMContextCommitCallback =
    Ptr () ->                               -- object
    CString ->
    Ptr () ->                               -- user_data
    IO ()

-- | Generate a function pointer callable from C code, from a `C_IMContextCommitCallback`.
foreign import ccall "wrapper"
    mk_IMContextCommitCallback :: C_IMContextCommitCallback -> IO (FunPtr C_IMContextCommitCallback)

-- | Wrap the callback into a `GClosure`.
genClosure_IMContextCommit :: MonadIO m => IMContextCommitCallback -> m (GClosure C_IMContextCommitCallback)
genClosure_IMContextCommit cb = liftIO $ do
    let cb' = wrap_IMContextCommitCallback cb
    mk_IMContextCommitCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `IMContextCommitCallback` into a `C_IMContextCommitCallback`.
wrap_IMContextCommitCallback ::
    IMContextCommitCallback ->
    C_IMContextCommitCallback
wrap_IMContextCommitCallback _cb _ str _ = do
    str' <- cstringToText str
    _cb  str'


-- | Connect a signal handler for the [commit](#signal:commit) signal, to be run before the default handler.
-- When <https://github.com/haskell-gi/haskell-gi/wiki/Overloading overloading> is enabled, this is equivalent to
-- 
-- @
-- 'Data.GI.Base.Signals.on' iMContext #commit callback
-- @
-- 
-- 
onIMContextCommit :: (IsIMContext a, MonadIO m) => a -> IMContextCommitCallback -> m SignalHandlerId
onIMContextCommit obj cb = liftIO $ do
    let cb' = wrap_IMContextCommitCallback cb
    cb'' <- mk_IMContextCommitCallback cb'
    connectSignalFunPtr obj "commit" cb'' SignalConnectBefore Nothing

-- | Connect a signal handler for the [commit](#signal:commit) signal, to be run after the default handler.
-- When <https://github.com/haskell-gi/haskell-gi/wiki/Overloading overloading> is enabled, this is equivalent to
-- 
-- @
-- 'Data.GI.Base.Signals.after' iMContext #commit callback
-- @
-- 
-- 
afterIMContextCommit :: (IsIMContext a, MonadIO m) => a -> IMContextCommitCallback -> m SignalHandlerId
afterIMContextCommit obj cb = liftIO $ do
    let cb' = wrap_IMContextCommitCallback cb
    cb'' <- mk_IMContextCommitCallback cb'
    connectSignalFunPtr obj "commit" cb'' SignalConnectAfter Nothing


#if defined(ENABLE_OVERLOADING)
data IMContextCommitSignalInfo
instance SignalInfo IMContextCommitSignalInfo where
    type HaskellCallbackType IMContextCommitSignalInfo = IMContextCommitCallback
    connectSignal obj cb connectMode detail = do
        let cb' = wrap_IMContextCommitCallback cb
        cb'' <- mk_IMContextCommitCallback cb'
        connectSignalFunPtr obj "commit" cb'' connectMode detail

#endif

-- signal IMContext::delete-surrounding
-- | The [deleteSurrounding](#signal:deleteSurrounding) signal is emitted when the input method
-- needs to delete all or part of the context surrounding the cursor.
type IMContextDeleteSurroundingCallback =
    Int32
    -- ^ /@offset@/: the character offset from the cursor position of the text
    --           to be deleted. A negative value indicates a position before
    --           the cursor.
    -> Int32
    -- ^ /@nChars@/: the number of characters to be deleted
    -> IO Bool
    -- ^ __Returns:__ 'P.True' if the signal was handled.

-- | A convenience synonym for @`Nothing` :: `Maybe` `IMContextDeleteSurroundingCallback`@.
noIMContextDeleteSurroundingCallback :: Maybe IMContextDeleteSurroundingCallback
noIMContextDeleteSurroundingCallback = Nothing

-- | Type for the callback on the (unwrapped) C side.
type C_IMContextDeleteSurroundingCallback =
    Ptr () ->                               -- object
    Int32 ->
    Int32 ->
    Ptr () ->                               -- user_data
    IO CInt

-- | Generate a function pointer callable from C code, from a `C_IMContextDeleteSurroundingCallback`.
foreign import ccall "wrapper"
    mk_IMContextDeleteSurroundingCallback :: C_IMContextDeleteSurroundingCallback -> IO (FunPtr C_IMContextDeleteSurroundingCallback)

-- | Wrap the callback into a `GClosure`.
genClosure_IMContextDeleteSurrounding :: MonadIO m => IMContextDeleteSurroundingCallback -> m (GClosure C_IMContextDeleteSurroundingCallback)
genClosure_IMContextDeleteSurrounding cb = liftIO $ do
    let cb' = wrap_IMContextDeleteSurroundingCallback cb
    mk_IMContextDeleteSurroundingCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `IMContextDeleteSurroundingCallback` into a `C_IMContextDeleteSurroundingCallback`.
wrap_IMContextDeleteSurroundingCallback ::
    IMContextDeleteSurroundingCallback ->
    C_IMContextDeleteSurroundingCallback
wrap_IMContextDeleteSurroundingCallback _cb _ offset nChars _ = do
    result <- _cb  offset nChars
    let result' = (fromIntegral . fromEnum) result
    return result'


-- | Connect a signal handler for the [deleteSurrounding](#signal:deleteSurrounding) signal, to be run before the default handler.
-- When <https://github.com/haskell-gi/haskell-gi/wiki/Overloading overloading> is enabled, this is equivalent to
-- 
-- @
-- 'Data.GI.Base.Signals.on' iMContext #deleteSurrounding callback
-- @
-- 
-- 
onIMContextDeleteSurrounding :: (IsIMContext a, MonadIO m) => a -> IMContextDeleteSurroundingCallback -> m SignalHandlerId
onIMContextDeleteSurrounding obj cb = liftIO $ do
    let cb' = wrap_IMContextDeleteSurroundingCallback cb
    cb'' <- mk_IMContextDeleteSurroundingCallback cb'
    connectSignalFunPtr obj "delete-surrounding" cb'' SignalConnectBefore Nothing

-- | Connect a signal handler for the [deleteSurrounding](#signal:deleteSurrounding) signal, to be run after the default handler.
-- When <https://github.com/haskell-gi/haskell-gi/wiki/Overloading overloading> is enabled, this is equivalent to
-- 
-- @
-- 'Data.GI.Base.Signals.after' iMContext #deleteSurrounding callback
-- @
-- 
-- 
afterIMContextDeleteSurrounding :: (IsIMContext a, MonadIO m) => a -> IMContextDeleteSurroundingCallback -> m SignalHandlerId
afterIMContextDeleteSurrounding obj cb = liftIO $ do
    let cb' = wrap_IMContextDeleteSurroundingCallback cb
    cb'' <- mk_IMContextDeleteSurroundingCallback cb'
    connectSignalFunPtr obj "delete-surrounding" cb'' SignalConnectAfter Nothing


#if defined(ENABLE_OVERLOADING)
data IMContextDeleteSurroundingSignalInfo
instance SignalInfo IMContextDeleteSurroundingSignalInfo where
    type HaskellCallbackType IMContextDeleteSurroundingSignalInfo = IMContextDeleteSurroundingCallback
    connectSignal obj cb connectMode detail = do
        let cb' = wrap_IMContextDeleteSurroundingCallback cb
        cb'' <- mk_IMContextDeleteSurroundingCallback cb'
        connectSignalFunPtr obj "delete-surrounding" cb'' connectMode detail

#endif

-- signal IMContext::preedit-changed
-- | The [preeditChanged](#signal:preeditChanged) signal is emitted whenever the preedit sequence
-- currently being entered has changed.  It is also emitted at the end of
-- a preedit sequence, in which case
-- 'GI.Gtk.Objects.IMContext.iMContextGetPreeditString' returns the empty string.
type IMContextPreeditChangedCallback =
    IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `IMContextPreeditChangedCallback`@.
noIMContextPreeditChangedCallback :: Maybe IMContextPreeditChangedCallback
noIMContextPreeditChangedCallback = Nothing

-- | Type for the callback on the (unwrapped) C side.
type C_IMContextPreeditChangedCallback =
    Ptr () ->                               -- object
    Ptr () ->                               -- user_data
    IO ()

-- | Generate a function pointer callable from C code, from a `C_IMContextPreeditChangedCallback`.
foreign import ccall "wrapper"
    mk_IMContextPreeditChangedCallback :: C_IMContextPreeditChangedCallback -> IO (FunPtr C_IMContextPreeditChangedCallback)

-- | Wrap the callback into a `GClosure`.
genClosure_IMContextPreeditChanged :: MonadIO m => IMContextPreeditChangedCallback -> m (GClosure C_IMContextPreeditChangedCallback)
genClosure_IMContextPreeditChanged cb = liftIO $ do
    let cb' = wrap_IMContextPreeditChangedCallback cb
    mk_IMContextPreeditChangedCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `IMContextPreeditChangedCallback` into a `C_IMContextPreeditChangedCallback`.
wrap_IMContextPreeditChangedCallback ::
    IMContextPreeditChangedCallback ->
    C_IMContextPreeditChangedCallback
wrap_IMContextPreeditChangedCallback _cb _ _ = do
    _cb 


-- | Connect a signal handler for the [preeditChanged](#signal:preeditChanged) signal, to be run before the default handler.
-- When <https://github.com/haskell-gi/haskell-gi/wiki/Overloading overloading> is enabled, this is equivalent to
-- 
-- @
-- 'Data.GI.Base.Signals.on' iMContext #preeditChanged callback
-- @
-- 
-- 
onIMContextPreeditChanged :: (IsIMContext a, MonadIO m) => a -> IMContextPreeditChangedCallback -> m SignalHandlerId
onIMContextPreeditChanged obj cb = liftIO $ do
    let cb' = wrap_IMContextPreeditChangedCallback cb
    cb'' <- mk_IMContextPreeditChangedCallback cb'
    connectSignalFunPtr obj "preedit-changed" cb'' SignalConnectBefore Nothing

-- | Connect a signal handler for the [preeditChanged](#signal:preeditChanged) signal, to be run after the default handler.
-- When <https://github.com/haskell-gi/haskell-gi/wiki/Overloading overloading> is enabled, this is equivalent to
-- 
-- @
-- 'Data.GI.Base.Signals.after' iMContext #preeditChanged callback
-- @
-- 
-- 
afterIMContextPreeditChanged :: (IsIMContext a, MonadIO m) => a -> IMContextPreeditChangedCallback -> m SignalHandlerId
afterIMContextPreeditChanged obj cb = liftIO $ do
    let cb' = wrap_IMContextPreeditChangedCallback cb
    cb'' <- mk_IMContextPreeditChangedCallback cb'
    connectSignalFunPtr obj "preedit-changed" cb'' SignalConnectAfter Nothing


#if defined(ENABLE_OVERLOADING)
data IMContextPreeditChangedSignalInfo
instance SignalInfo IMContextPreeditChangedSignalInfo where
    type HaskellCallbackType IMContextPreeditChangedSignalInfo = IMContextPreeditChangedCallback
    connectSignal obj cb connectMode detail = do
        let cb' = wrap_IMContextPreeditChangedCallback cb
        cb'' <- mk_IMContextPreeditChangedCallback cb'
        connectSignalFunPtr obj "preedit-changed" cb'' connectMode detail

#endif

-- signal IMContext::preedit-end
-- | The [preeditEnd](#signal:preeditEnd) signal is emitted when a preediting sequence
-- has been completed or canceled.
type IMContextPreeditEndCallback =
    IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `IMContextPreeditEndCallback`@.
noIMContextPreeditEndCallback :: Maybe IMContextPreeditEndCallback
noIMContextPreeditEndCallback = Nothing

-- | Type for the callback on the (unwrapped) C side.
type C_IMContextPreeditEndCallback =
    Ptr () ->                               -- object
    Ptr () ->                               -- user_data
    IO ()

-- | Generate a function pointer callable from C code, from a `C_IMContextPreeditEndCallback`.
foreign import ccall "wrapper"
    mk_IMContextPreeditEndCallback :: C_IMContextPreeditEndCallback -> IO (FunPtr C_IMContextPreeditEndCallback)

-- | Wrap the callback into a `GClosure`.
genClosure_IMContextPreeditEnd :: MonadIO m => IMContextPreeditEndCallback -> m (GClosure C_IMContextPreeditEndCallback)
genClosure_IMContextPreeditEnd cb = liftIO $ do
    let cb' = wrap_IMContextPreeditEndCallback cb
    mk_IMContextPreeditEndCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `IMContextPreeditEndCallback` into a `C_IMContextPreeditEndCallback`.
wrap_IMContextPreeditEndCallback ::
    IMContextPreeditEndCallback ->
    C_IMContextPreeditEndCallback
wrap_IMContextPreeditEndCallback _cb _ _ = do
    _cb 


-- | Connect a signal handler for the [preeditEnd](#signal:preeditEnd) signal, to be run before the default handler.
-- When <https://github.com/haskell-gi/haskell-gi/wiki/Overloading overloading> is enabled, this is equivalent to
-- 
-- @
-- 'Data.GI.Base.Signals.on' iMContext #preeditEnd callback
-- @
-- 
-- 
onIMContextPreeditEnd :: (IsIMContext a, MonadIO m) => a -> IMContextPreeditEndCallback -> m SignalHandlerId
onIMContextPreeditEnd obj cb = liftIO $ do
    let cb' = wrap_IMContextPreeditEndCallback cb
    cb'' <- mk_IMContextPreeditEndCallback cb'
    connectSignalFunPtr obj "preedit-end" cb'' SignalConnectBefore Nothing

-- | Connect a signal handler for the [preeditEnd](#signal:preeditEnd) signal, to be run after the default handler.
-- When <https://github.com/haskell-gi/haskell-gi/wiki/Overloading overloading> is enabled, this is equivalent to
-- 
-- @
-- 'Data.GI.Base.Signals.after' iMContext #preeditEnd callback
-- @
-- 
-- 
afterIMContextPreeditEnd :: (IsIMContext a, MonadIO m) => a -> IMContextPreeditEndCallback -> m SignalHandlerId
afterIMContextPreeditEnd obj cb = liftIO $ do
    let cb' = wrap_IMContextPreeditEndCallback cb
    cb'' <- mk_IMContextPreeditEndCallback cb'
    connectSignalFunPtr obj "preedit-end" cb'' SignalConnectAfter Nothing


#if defined(ENABLE_OVERLOADING)
data IMContextPreeditEndSignalInfo
instance SignalInfo IMContextPreeditEndSignalInfo where
    type HaskellCallbackType IMContextPreeditEndSignalInfo = IMContextPreeditEndCallback
    connectSignal obj cb connectMode detail = do
        let cb' = wrap_IMContextPreeditEndCallback cb
        cb'' <- mk_IMContextPreeditEndCallback cb'
        connectSignalFunPtr obj "preedit-end" cb'' connectMode detail

#endif

-- signal IMContext::preedit-start
-- | The [preeditStart](#signal:preeditStart) signal is emitted when a new preediting sequence
-- starts.
type IMContextPreeditStartCallback =
    IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `IMContextPreeditStartCallback`@.
noIMContextPreeditStartCallback :: Maybe IMContextPreeditStartCallback
noIMContextPreeditStartCallback = Nothing

-- | Type for the callback on the (unwrapped) C side.
type C_IMContextPreeditStartCallback =
    Ptr () ->                               -- object
    Ptr () ->                               -- user_data
    IO ()

-- | Generate a function pointer callable from C code, from a `C_IMContextPreeditStartCallback`.
foreign import ccall "wrapper"
    mk_IMContextPreeditStartCallback :: C_IMContextPreeditStartCallback -> IO (FunPtr C_IMContextPreeditStartCallback)

-- | Wrap the callback into a `GClosure`.
genClosure_IMContextPreeditStart :: MonadIO m => IMContextPreeditStartCallback -> m (GClosure C_IMContextPreeditStartCallback)
genClosure_IMContextPreeditStart cb = liftIO $ do
    let cb' = wrap_IMContextPreeditStartCallback cb
    mk_IMContextPreeditStartCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `IMContextPreeditStartCallback` into a `C_IMContextPreeditStartCallback`.
wrap_IMContextPreeditStartCallback ::
    IMContextPreeditStartCallback ->
    C_IMContextPreeditStartCallback
wrap_IMContextPreeditStartCallback _cb _ _ = do
    _cb 


-- | Connect a signal handler for the [preeditStart](#signal:preeditStart) signal, to be run before the default handler.
-- When <https://github.com/haskell-gi/haskell-gi/wiki/Overloading overloading> is enabled, this is equivalent to
-- 
-- @
-- 'Data.GI.Base.Signals.on' iMContext #preeditStart callback
-- @
-- 
-- 
onIMContextPreeditStart :: (IsIMContext a, MonadIO m) => a -> IMContextPreeditStartCallback -> m SignalHandlerId
onIMContextPreeditStart obj cb = liftIO $ do
    let cb' = wrap_IMContextPreeditStartCallback cb
    cb'' <- mk_IMContextPreeditStartCallback cb'
    connectSignalFunPtr obj "preedit-start" cb'' SignalConnectBefore Nothing

-- | Connect a signal handler for the [preeditStart](#signal:preeditStart) signal, to be run after the default handler.
-- When <https://github.com/haskell-gi/haskell-gi/wiki/Overloading overloading> is enabled, this is equivalent to
-- 
-- @
-- 'Data.GI.Base.Signals.after' iMContext #preeditStart callback
-- @
-- 
-- 
afterIMContextPreeditStart :: (IsIMContext a, MonadIO m) => a -> IMContextPreeditStartCallback -> m SignalHandlerId
afterIMContextPreeditStart obj cb = liftIO $ do
    let cb' = wrap_IMContextPreeditStartCallback cb
    cb'' <- mk_IMContextPreeditStartCallback cb'
    connectSignalFunPtr obj "preedit-start" cb'' SignalConnectAfter Nothing


#if defined(ENABLE_OVERLOADING)
data IMContextPreeditStartSignalInfo
instance SignalInfo IMContextPreeditStartSignalInfo where
    type HaskellCallbackType IMContextPreeditStartSignalInfo = IMContextPreeditStartCallback
    connectSignal obj cb connectMode detail = do
        let cb' = wrap_IMContextPreeditStartCallback cb
        cb'' <- mk_IMContextPreeditStartCallback cb'
        connectSignalFunPtr obj "preedit-start" cb'' connectMode detail

#endif

-- signal IMContext::retrieve-surrounding
-- | The [retrieveSurrounding](#signal:retrieveSurrounding) signal is emitted when the input method
-- requires the context surrounding the cursor.  The callback should set
-- the input method surrounding context by calling the
-- 'GI.Gtk.Objects.IMContext.iMContextSetSurrounding' method.
type IMContextRetrieveSurroundingCallback =
    IO Bool
    -- ^ __Returns:__ 'P.True' if the signal was handled.

-- | A convenience synonym for @`Nothing` :: `Maybe` `IMContextRetrieveSurroundingCallback`@.
noIMContextRetrieveSurroundingCallback :: Maybe IMContextRetrieveSurroundingCallback
noIMContextRetrieveSurroundingCallback = Nothing

-- | Type for the callback on the (unwrapped) C side.
type C_IMContextRetrieveSurroundingCallback =
    Ptr () ->                               -- object
    Ptr () ->                               -- user_data
    IO CInt

-- | Generate a function pointer callable from C code, from a `C_IMContextRetrieveSurroundingCallback`.
foreign import ccall "wrapper"
    mk_IMContextRetrieveSurroundingCallback :: C_IMContextRetrieveSurroundingCallback -> IO (FunPtr C_IMContextRetrieveSurroundingCallback)

-- | Wrap the callback into a `GClosure`.
genClosure_IMContextRetrieveSurrounding :: MonadIO m => IMContextRetrieveSurroundingCallback -> m (GClosure C_IMContextRetrieveSurroundingCallback)
genClosure_IMContextRetrieveSurrounding cb = liftIO $ do
    let cb' = wrap_IMContextRetrieveSurroundingCallback cb
    mk_IMContextRetrieveSurroundingCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `IMContextRetrieveSurroundingCallback` into a `C_IMContextRetrieveSurroundingCallback`.
wrap_IMContextRetrieveSurroundingCallback ::
    IMContextRetrieveSurroundingCallback ->
    C_IMContextRetrieveSurroundingCallback
wrap_IMContextRetrieveSurroundingCallback _cb _ _ = do
    result <- _cb 
    let result' = (fromIntegral . fromEnum) result
    return result'


-- | Connect a signal handler for the [retrieveSurrounding](#signal:retrieveSurrounding) signal, to be run before the default handler.
-- When <https://github.com/haskell-gi/haskell-gi/wiki/Overloading overloading> is enabled, this is equivalent to
-- 
-- @
-- 'Data.GI.Base.Signals.on' iMContext #retrieveSurrounding callback
-- @
-- 
-- 
onIMContextRetrieveSurrounding :: (IsIMContext a, MonadIO m) => a -> IMContextRetrieveSurroundingCallback -> m SignalHandlerId
onIMContextRetrieveSurrounding obj cb = liftIO $ do
    let cb' = wrap_IMContextRetrieveSurroundingCallback cb
    cb'' <- mk_IMContextRetrieveSurroundingCallback cb'
    connectSignalFunPtr obj "retrieve-surrounding" cb'' SignalConnectBefore Nothing

-- | Connect a signal handler for the [retrieveSurrounding](#signal:retrieveSurrounding) signal, to be run after the default handler.
-- When <https://github.com/haskell-gi/haskell-gi/wiki/Overloading overloading> is enabled, this is equivalent to
-- 
-- @
-- 'Data.GI.Base.Signals.after' iMContext #retrieveSurrounding callback
-- @
-- 
-- 
afterIMContextRetrieveSurrounding :: (IsIMContext a, MonadIO m) => a -> IMContextRetrieveSurroundingCallback -> m SignalHandlerId
afterIMContextRetrieveSurrounding obj cb = liftIO $ do
    let cb' = wrap_IMContextRetrieveSurroundingCallback cb
    cb'' <- mk_IMContextRetrieveSurroundingCallback cb'
    connectSignalFunPtr obj "retrieve-surrounding" cb'' SignalConnectAfter Nothing


#if defined(ENABLE_OVERLOADING)
data IMContextRetrieveSurroundingSignalInfo
instance SignalInfo IMContextRetrieveSurroundingSignalInfo where
    type HaskellCallbackType IMContextRetrieveSurroundingSignalInfo = IMContextRetrieveSurroundingCallback
    connectSignal obj cb connectMode detail = do
        let cb' = wrap_IMContextRetrieveSurroundingCallback cb
        cb'' <- mk_IMContextRetrieveSurroundingCallback cb'
        connectSignalFunPtr obj "retrieve-surrounding" cb'' connectMode detail

#endif

-- VVV Prop "input-hints"
   -- Type: TInterface (Name {namespace = "Gtk", name = "InputHints"})
   -- Flags: [PropertyReadable,PropertyWritable]
   -- Nullable: (Nothing,Nothing)

-- | Get the value of the “@input-hints@” property.
-- When <https://github.com/haskell-gi/haskell-gi/wiki/Overloading overloading> is enabled, this is equivalent to
-- 
-- @
-- 'Data.GI.Base.Attributes.get' iMContext #inputHints
-- @
getIMContextInputHints :: (MonadIO m, IsIMContext o) => o -> m [Gtk.Flags.InputHints]
getIMContextInputHints obj = liftIO $ B.Properties.getObjectPropertyFlags obj "input-hints"

-- | Set the value of the “@input-hints@” property.
-- When <https://github.com/haskell-gi/haskell-gi/wiki/Overloading overloading> is enabled, this is equivalent to
-- 
-- @
-- 'Data.GI.Base.Attributes.set' iMContext [ #inputHints 'Data.GI.Base.Attributes.:=' value ]
-- @
setIMContextInputHints :: (MonadIO m, IsIMContext o) => o -> [Gtk.Flags.InputHints] -> m ()
setIMContextInputHints obj val = liftIO $ B.Properties.setObjectPropertyFlags obj "input-hints" val

-- | Construct a `GValueConstruct` with valid value for the “@input-hints@” property. This is rarely needed directly, but it is used by `Data.GI.Base.Constructible.new`.
constructIMContextInputHints :: (IsIMContext o) => [Gtk.Flags.InputHints] -> IO (GValueConstruct o)
constructIMContextInputHints val = B.Properties.constructObjectPropertyFlags "input-hints" val

#if defined(ENABLE_OVERLOADING)
data IMContextInputHintsPropertyInfo
instance AttrInfo IMContextInputHintsPropertyInfo where
    type AttrAllowedOps IMContextInputHintsPropertyInfo = '[ 'AttrSet, 'AttrConstruct, 'AttrGet]
    type AttrBaseTypeConstraint IMContextInputHintsPropertyInfo = IsIMContext
    type AttrSetTypeConstraint IMContextInputHintsPropertyInfo = (~) [Gtk.Flags.InputHints]
    type AttrTransferTypeConstraint IMContextInputHintsPropertyInfo = (~) [Gtk.Flags.InputHints]
    type AttrTransferType IMContextInputHintsPropertyInfo = [Gtk.Flags.InputHints]
    type AttrGetType IMContextInputHintsPropertyInfo = [Gtk.Flags.InputHints]
    type AttrLabel IMContextInputHintsPropertyInfo = "input-hints"
    type AttrOrigin IMContextInputHintsPropertyInfo = IMContext
    attrGet = getIMContextInputHints
    attrSet = setIMContextInputHints
    attrTransfer _ v = do
        return v
    attrConstruct = constructIMContextInputHints
    attrClear = undefined
#endif

-- VVV Prop "input-purpose"
   -- Type: TInterface (Name {namespace = "Gtk", name = "InputPurpose"})
   -- Flags: [PropertyReadable,PropertyWritable]
   -- Nullable: (Nothing,Nothing)

-- | Get the value of the “@input-purpose@” property.
-- When <https://github.com/haskell-gi/haskell-gi/wiki/Overloading overloading> is enabled, this is equivalent to
-- 
-- @
-- 'Data.GI.Base.Attributes.get' iMContext #inputPurpose
-- @
getIMContextInputPurpose :: (MonadIO m, IsIMContext o) => o -> m Gtk.Enums.InputPurpose
getIMContextInputPurpose obj = liftIO $ B.Properties.getObjectPropertyEnum obj "input-purpose"

-- | Set the value of the “@input-purpose@” property.
-- When <https://github.com/haskell-gi/haskell-gi/wiki/Overloading overloading> is enabled, this is equivalent to
-- 
-- @
-- 'Data.GI.Base.Attributes.set' iMContext [ #inputPurpose 'Data.GI.Base.Attributes.:=' value ]
-- @
setIMContextInputPurpose :: (MonadIO m, IsIMContext o) => o -> Gtk.Enums.InputPurpose -> m ()
setIMContextInputPurpose obj val = liftIO $ B.Properties.setObjectPropertyEnum obj "input-purpose" val

-- | Construct a `GValueConstruct` with valid value for the “@input-purpose@” property. This is rarely needed directly, but it is used by `Data.GI.Base.Constructible.new`.
constructIMContextInputPurpose :: (IsIMContext o) => Gtk.Enums.InputPurpose -> IO (GValueConstruct o)
constructIMContextInputPurpose val = B.Properties.constructObjectPropertyEnum "input-purpose" val

#if defined(ENABLE_OVERLOADING)
data IMContextInputPurposePropertyInfo
instance AttrInfo IMContextInputPurposePropertyInfo where
    type AttrAllowedOps IMContextInputPurposePropertyInfo = '[ 'AttrSet, 'AttrConstruct, 'AttrGet]
    type AttrBaseTypeConstraint IMContextInputPurposePropertyInfo = IsIMContext
    type AttrSetTypeConstraint IMContextInputPurposePropertyInfo = (~) Gtk.Enums.InputPurpose
    type AttrTransferTypeConstraint IMContextInputPurposePropertyInfo = (~) Gtk.Enums.InputPurpose
    type AttrTransferType IMContextInputPurposePropertyInfo = Gtk.Enums.InputPurpose
    type AttrGetType IMContextInputPurposePropertyInfo = Gtk.Enums.InputPurpose
    type AttrLabel IMContextInputPurposePropertyInfo = "input-purpose"
    type AttrOrigin IMContextInputPurposePropertyInfo = IMContext
    attrGet = getIMContextInputPurpose
    attrSet = setIMContextInputPurpose
    attrTransfer _ v = do
        return v
    attrConstruct = constructIMContextInputPurpose
    attrClear = undefined
#endif

#if defined(ENABLE_OVERLOADING)
instance O.HasAttributeList IMContext
type instance O.AttributeList IMContext = IMContextAttributeList
type IMContextAttributeList = ('[ '("inputHints", IMContextInputHintsPropertyInfo), '("inputPurpose", IMContextInputPurposePropertyInfo)] :: [(Symbol, *)])
#endif

#if defined(ENABLE_OVERLOADING)
iMContextInputHints :: AttrLabelProxy "inputHints"
iMContextInputHints = AttrLabelProxy

iMContextInputPurpose :: AttrLabelProxy "inputPurpose"
iMContextInputPurpose = AttrLabelProxy

#endif

#if defined(ENABLE_OVERLOADING)
type instance O.SignalList IMContext = IMContextSignalList
type IMContextSignalList = ('[ '("commit", IMContextCommitSignalInfo), '("deleteSurrounding", IMContextDeleteSurroundingSignalInfo), '("notify", GObject.Object.ObjectNotifySignalInfo), '("preeditChanged", IMContextPreeditChangedSignalInfo), '("preeditEnd", IMContextPreeditEndSignalInfo), '("preeditStart", IMContextPreeditStartSignalInfo), '("retrieveSurrounding", IMContextRetrieveSurroundingSignalInfo)] :: [(Symbol, *)])

#endif

-- method IMContext::delete_surrounding
-- method type : OrdinaryMethod
-- Args: [ Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "IMContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkIMContext" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "offset"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "offset from cursor position in chars;\n   a negative value means start before the cursor."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "n_chars"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "number of characters to delete."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "gtk_im_context_delete_surrounding" gtk_im_context_delete_surrounding :: 
    Ptr IMContext ->                        -- context : TInterface (Name {namespace = "Gtk", name = "IMContext"})
    Int32 ->                                -- offset : TBasicType TInt
    Int32 ->                                -- n_chars : TBasicType TInt
    IO CInt

-- | Asks the widget that the input context is attached to to delete
-- characters around the cursor position by emitting the
-- GtkIMContext[delete_surrounding](#signal:delete_surrounding) signal. Note that /@offset@/ and /@nChars@/
-- are in characters not in bytes which differs from the usage other
-- places in t'GI.Gtk.Objects.IMContext.IMContext'.
-- 
-- In order to use this function, you should first call
-- 'GI.Gtk.Objects.IMContext.iMContextGetSurrounding' to get the current context, and
-- call this function immediately afterwards to make sure that you
-- know what you are deleting. You should also account for the fact
-- that even if the signal was handled, the input context might not
-- have deleted all the characters that were requested to be deleted.
-- 
-- This function is used by an input method that wants to make
-- subsitutions in the existing text in response to new input. It is
-- not useful for applications.
iMContextDeleteSurrounding ::
    (B.CallStack.HasCallStack, MonadIO m, IsIMContext a) =>
    a
    -- ^ /@context@/: a t'GI.Gtk.Objects.IMContext.IMContext'
    -> Int32
    -- ^ /@offset@/: offset from cursor position in chars;
    --    a negative value means start before the cursor.
    -> Int32
    -- ^ /@nChars@/: number of characters to delete.
    -> m Bool
    -- ^ __Returns:__ 'P.True' if the signal was handled.
iMContextDeleteSurrounding context offset nChars = liftIO $ do
    context' <- unsafeManagedPtrCastPtr context
    result <- gtk_im_context_delete_surrounding context' offset nChars
    let result' = (/= 0) result
    touchManagedPtr context
    return result'

#if defined(ENABLE_OVERLOADING)
data IMContextDeleteSurroundingMethodInfo
instance (signature ~ (Int32 -> Int32 -> m Bool), MonadIO m, IsIMContext a) => O.MethodInfo IMContextDeleteSurroundingMethodInfo a signature where
    overloadedMethod = iMContextDeleteSurrounding

#endif

-- method IMContext::filter_keypress
-- method type : OrdinaryMethod
-- Args: [ Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "IMContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkIMContext" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventKey" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the key event" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "gtk_im_context_filter_keypress" gtk_im_context_filter_keypress :: 
    Ptr IMContext ->                        -- context : TInterface (Name {namespace = "Gtk", name = "IMContext"})
    Ptr Gdk.EventKey.EventKey ->            -- event : TInterface (Name {namespace = "Gdk", name = "EventKey"})
    IO CInt

-- | Allow an input method to internally handle key press and release
-- events. If this function returns 'P.True', then no further processing
-- should be done for this key event.
iMContextFilterKeypress ::
    (B.CallStack.HasCallStack, MonadIO m, IsIMContext a) =>
    a
    -- ^ /@context@/: a t'GI.Gtk.Objects.IMContext.IMContext'
    -> Gdk.EventKey.EventKey
    -- ^ /@event@/: the key event
    -> m Bool
    -- ^ __Returns:__ 'P.True' if the input method handled the key event.
iMContextFilterKeypress context event = liftIO $ do
    context' <- unsafeManagedPtrCastPtr context
    event' <- unsafeManagedPtrGetPtr event
    result <- gtk_im_context_filter_keypress context' event'
    let result' = (/= 0) result
    touchManagedPtr context
    touchManagedPtr event
    return result'

#if defined(ENABLE_OVERLOADING)
data IMContextFilterKeypressMethodInfo
instance (signature ~ (Gdk.EventKey.EventKey -> m Bool), MonadIO m, IsIMContext a) => O.MethodInfo IMContextFilterKeypressMethodInfo a signature where
    overloadedMethod = iMContextFilterKeypress

#endif

-- method IMContext::focus_in
-- method type : OrdinaryMethod
-- Args: [ Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "IMContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkIMContext" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "gtk_im_context_focus_in" gtk_im_context_focus_in :: 
    Ptr IMContext ->                        -- context : TInterface (Name {namespace = "Gtk", name = "IMContext"})
    IO ()

-- | Notify the input method that the widget to which this
-- input context corresponds has gained focus. The input method
-- may, for example, change the displayed feedback to reflect
-- this change.
iMContextFocusIn ::
    (B.CallStack.HasCallStack, MonadIO m, IsIMContext a) =>
    a
    -- ^ /@context@/: a t'GI.Gtk.Objects.IMContext.IMContext'
    -> m ()
iMContextFocusIn context = liftIO $ do
    context' <- unsafeManagedPtrCastPtr context
    gtk_im_context_focus_in context'
    touchManagedPtr context
    return ()

#if defined(ENABLE_OVERLOADING)
data IMContextFocusInMethodInfo
instance (signature ~ (m ()), MonadIO m, IsIMContext a) => O.MethodInfo IMContextFocusInMethodInfo a signature where
    overloadedMethod = iMContextFocusIn

#endif

-- method IMContext::focus_out
-- method type : OrdinaryMethod
-- Args: [ Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "IMContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkIMContext" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "gtk_im_context_focus_out" gtk_im_context_focus_out :: 
    Ptr IMContext ->                        -- context : TInterface (Name {namespace = "Gtk", name = "IMContext"})
    IO ()

-- | Notify the input method that the widget to which this
-- input context corresponds has lost focus. The input method
-- may, for example, change the displayed feedback or reset the contexts
-- state to reflect this change.
iMContextFocusOut ::
    (B.CallStack.HasCallStack, MonadIO m, IsIMContext a) =>
    a
    -- ^ /@context@/: a t'GI.Gtk.Objects.IMContext.IMContext'
    -> m ()
iMContextFocusOut context = liftIO $ do
    context' <- unsafeManagedPtrCastPtr context
    gtk_im_context_focus_out context'
    touchManagedPtr context
    return ()

#if defined(ENABLE_OVERLOADING)
data IMContextFocusOutMethodInfo
instance (signature ~ (m ()), MonadIO m, IsIMContext a) => O.MethodInfo IMContextFocusOutMethodInfo a signature where
    overloadedMethod = iMContextFocusOut

#endif

-- method IMContext::get_preedit_string
-- method type : OrdinaryMethod
-- Args: [ Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "IMContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkIMContext" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "str"
--           , argType = TBasicType TUTF8
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "location to store the retrieved\n             string. The string retrieved must be freed with g_free()."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       , Arg
--           { argCName = "attrs"
--           , argType =
--               TInterface Name { namespace = "Pango" , name = "AttrList" }
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "location to store the retrieved\n             attribute list.  When you are done with this list, you\n             must unreference it with pango_attr_list_unref()."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       , Arg
--           { argCName = "cursor_pos"
--           , argType = TBasicType TInt
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "location to store position of cursor (in characters)\n             within the preedit string."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "gtk_im_context_get_preedit_string" gtk_im_context_get_preedit_string :: 
    Ptr IMContext ->                        -- context : TInterface (Name {namespace = "Gtk", name = "IMContext"})
    Ptr CString ->                          -- str : TBasicType TUTF8
    Ptr (Ptr Pango.AttrList.AttrList) ->    -- attrs : TInterface (Name {namespace = "Pango", name = "AttrList"})
    Ptr Int32 ->                            -- cursor_pos : TBasicType TInt
    IO ()

-- | Retrieve the current preedit string for the input context,
-- and a list of attributes to apply to the string.
-- This string should be displayed inserted at the insertion
-- point.
iMContextGetPreeditString ::
    (B.CallStack.HasCallStack, MonadIO m, IsIMContext a) =>
    a
    -- ^ /@context@/: a t'GI.Gtk.Objects.IMContext.IMContext'
    -> m ((T.Text, Pango.AttrList.AttrList, Int32))
iMContextGetPreeditString context = liftIO $ do
    context' <- unsafeManagedPtrCastPtr context
    str <- allocMem :: IO (Ptr CString)
    attrs <- allocMem :: IO (Ptr (Ptr Pango.AttrList.AttrList))
    cursorPos <- allocMem :: IO (Ptr Int32)
    gtk_im_context_get_preedit_string context' str attrs cursorPos
    str' <- peek str
    str'' <- cstringToText str'
    freeMem str'
    attrs' <- peek attrs
    attrs'' <- (wrapBoxed Pango.AttrList.AttrList) attrs'
    cursorPos' <- peek cursorPos
    touchManagedPtr context
    freeMem str
    freeMem attrs
    freeMem cursorPos
    return (str'', attrs'', cursorPos')

#if defined(ENABLE_OVERLOADING)
data IMContextGetPreeditStringMethodInfo
instance (signature ~ (m ((T.Text, Pango.AttrList.AttrList, Int32))), MonadIO m, IsIMContext a) => O.MethodInfo IMContextGetPreeditStringMethodInfo a signature where
    overloadedMethod = iMContextGetPreeditString

#endif

-- method IMContext::get_surrounding
-- method type : OrdinaryMethod
-- Args: [ Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "IMContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkIMContext" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "text"
--           , argType = TBasicType TUTF8
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "location to store a UTF-8 encoded\n       string of text holding context around the insertion point.\n       If the function returns %TRUE, then you must free the result\n       stored in this location with g_free()."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       , Arg
--           { argCName = "cursor_index"
--           , argType = TBasicType TInt
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "location to store byte index of the insertion\n       cursor within @text."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "gtk_im_context_get_surrounding" gtk_im_context_get_surrounding :: 
    Ptr IMContext ->                        -- context : TInterface (Name {namespace = "Gtk", name = "IMContext"})
    Ptr CString ->                          -- text : TBasicType TUTF8
    Ptr Int32 ->                            -- cursor_index : TBasicType TInt
    IO CInt

-- | Retrieves context around the insertion point. Input methods
-- typically want context in order to constrain input text based on
-- existing text; this is important for languages such as Thai where
-- only some sequences of characters are allowed.
-- 
-- This function is implemented by emitting the
-- GtkIMContext[retrieve_surrounding](#signal:retrieve_surrounding) signal on the input method; in
-- response to this signal, a widget should provide as much context as
-- is available, up to an entire paragraph, by calling
-- 'GI.Gtk.Objects.IMContext.iMContextSetSurrounding'. Note that there is no obligation
-- for a widget to respond to the [retrieve_surrounding](#signal:retrieve_surrounding) signal, so input
-- methods must be prepared to function without context.
iMContextGetSurrounding ::
    (B.CallStack.HasCallStack, MonadIO m, IsIMContext a) =>
    a
    -- ^ /@context@/: a t'GI.Gtk.Objects.IMContext.IMContext'
    -> m ((Bool, T.Text, Int32))
    -- ^ __Returns:__ 'P.True' if surrounding text was provided; in this case
    --    you must free the result stored in *text.
iMContextGetSurrounding context = liftIO $ do
    context' <- unsafeManagedPtrCastPtr context
    text <- allocMem :: IO (Ptr CString)
    cursorIndex <- allocMem :: IO (Ptr Int32)
    result <- gtk_im_context_get_surrounding context' text cursorIndex
    let result' = (/= 0) result
    text' <- peek text
    text'' <- cstringToText text'
    freeMem text'
    cursorIndex' <- peek cursorIndex
    touchManagedPtr context
    freeMem text
    freeMem cursorIndex
    return (result', text'', cursorIndex')

#if defined(ENABLE_OVERLOADING)
data IMContextGetSurroundingMethodInfo
instance (signature ~ (m ((Bool, T.Text, Int32))), MonadIO m, IsIMContext a) => O.MethodInfo IMContextGetSurroundingMethodInfo a signature where
    overloadedMethod = iMContextGetSurrounding

#endif

-- method IMContext::reset
-- method type : OrdinaryMethod
-- Args: [ Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "IMContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkIMContext" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "gtk_im_context_reset" gtk_im_context_reset :: 
    Ptr IMContext ->                        -- context : TInterface (Name {namespace = "Gtk", name = "IMContext"})
    IO ()

-- | Notify the input method that a change such as a change in cursor
-- position has been made. This will typically cause the input
-- method to clear the preedit state.
iMContextReset ::
    (B.CallStack.HasCallStack, MonadIO m, IsIMContext a) =>
    a
    -- ^ /@context@/: a t'GI.Gtk.Objects.IMContext.IMContext'
    -> m ()
iMContextReset context = liftIO $ do
    context' <- unsafeManagedPtrCastPtr context
    gtk_im_context_reset context'
    touchManagedPtr context
    return ()

#if defined(ENABLE_OVERLOADING)
data IMContextResetMethodInfo
instance (signature ~ (m ()), MonadIO m, IsIMContext a) => O.MethodInfo IMContextResetMethodInfo a signature where
    overloadedMethod = iMContextReset

#endif

-- method IMContext::set_client_window
-- method type : OrdinaryMethod
-- Args: [ Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "IMContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkIMContext" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "window"
--           , argType = TInterface Name { namespace = "Gdk" , name = "Window" }
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "the client window. This may be %NULL to indicate\n          that the previous client window no longer exists."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "gtk_im_context_set_client_window" gtk_im_context_set_client_window :: 
    Ptr IMContext ->                        -- context : TInterface (Name {namespace = "Gtk", name = "IMContext"})
    Ptr Gdk.Window.Window ->                -- window : TInterface (Name {namespace = "Gdk", name = "Window"})
    IO ()

-- | Set the client window for the input context; this is the
-- t'GI.Gdk.Objects.Window.Window' in which the input appears. This window is
-- used in order to correctly position status windows, and may
-- also be used for purposes internal to the input method.
iMContextSetClientWindow ::
    (B.CallStack.HasCallStack, MonadIO m, IsIMContext a, Gdk.Window.IsWindow b) =>
    a
    -- ^ /@context@/: a t'GI.Gtk.Objects.IMContext.IMContext'
    -> Maybe (b)
    -- ^ /@window@/: the client window. This may be 'P.Nothing' to indicate
    --           that the previous client window no longer exists.
    -> m ()
iMContextSetClientWindow context window = liftIO $ do
    context' <- unsafeManagedPtrCastPtr context
    maybeWindow <- case window of
        Nothing -> return nullPtr
        Just jWindow -> do
            jWindow' <- unsafeManagedPtrCastPtr jWindow
            return jWindow'
    gtk_im_context_set_client_window context' maybeWindow
    touchManagedPtr context
    whenJust window touchManagedPtr
    return ()

#if defined(ENABLE_OVERLOADING)
data IMContextSetClientWindowMethodInfo
instance (signature ~ (Maybe (b) -> m ()), MonadIO m, IsIMContext a, Gdk.Window.IsWindow b) => O.MethodInfo IMContextSetClientWindowMethodInfo a signature where
    overloadedMethod = iMContextSetClientWindow

#endif

-- method IMContext::set_cursor_location
-- method type : OrdinaryMethod
-- Args: [ Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "IMContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkIMContext" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "area"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "Rectangle" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "new location" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "gtk_im_context_set_cursor_location" gtk_im_context_set_cursor_location :: 
    Ptr IMContext ->                        -- context : TInterface (Name {namespace = "Gtk", name = "IMContext"})
    Ptr Gdk.Rectangle.Rectangle ->          -- area : TInterface (Name {namespace = "Gdk", name = "Rectangle"})
    IO ()

-- | Notify the input method that a change in cursor
-- position has been made. The location is relative to the client
-- window.
iMContextSetCursorLocation ::
    (B.CallStack.HasCallStack, MonadIO m, IsIMContext a) =>
    a
    -- ^ /@context@/: a t'GI.Gtk.Objects.IMContext.IMContext'
    -> Gdk.Rectangle.Rectangle
    -- ^ /@area@/: new location
    -> m ()
iMContextSetCursorLocation context area = liftIO $ do
    context' <- unsafeManagedPtrCastPtr context
    area' <- unsafeManagedPtrGetPtr area
    gtk_im_context_set_cursor_location context' area'
    touchManagedPtr context
    touchManagedPtr area
    return ()

#if defined(ENABLE_OVERLOADING)
data IMContextSetCursorLocationMethodInfo
instance (signature ~ (Gdk.Rectangle.Rectangle -> m ()), MonadIO m, IsIMContext a) => O.MethodInfo IMContextSetCursorLocationMethodInfo a signature where
    overloadedMethod = iMContextSetCursorLocation

#endif

-- method IMContext::set_surrounding
-- method type : OrdinaryMethod
-- Args: [ Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "IMContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkIMContext" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "text"
--           , argType = TBasicType TUTF8
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "text surrounding the insertion point, as UTF-8.\n       the preedit string should not be included within\n       @text."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "len"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "the length of @text, or -1 if @text is nul-terminated"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "cursor_index"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "the byte index of the insertion cursor within @text."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "gtk_im_context_set_surrounding" gtk_im_context_set_surrounding :: 
    Ptr IMContext ->                        -- context : TInterface (Name {namespace = "Gtk", name = "IMContext"})
    CString ->                              -- text : TBasicType TUTF8
    Int32 ->                                -- len : TBasicType TInt
    Int32 ->                                -- cursor_index : TBasicType TInt
    IO ()

-- | Sets surrounding context around the insertion point and preedit
-- string. This function is expected to be called in response to the
-- GtkIMContext[retrieve_surrounding](#signal:retrieve_surrounding) signal, and will likely have no
-- effect if called at other times.
iMContextSetSurrounding ::
    (B.CallStack.HasCallStack, MonadIO m, IsIMContext a) =>
    a
    -- ^ /@context@/: a t'GI.Gtk.Objects.IMContext.IMContext'
    -> T.Text
    -- ^ /@text@/: text surrounding the insertion point, as UTF-8.
    --        the preedit string should not be included within
    --        /@text@/.
    -> Int32
    -- ^ /@len@/: the length of /@text@/, or -1 if /@text@/ is nul-terminated
    -> Int32
    -- ^ /@cursorIndex@/: the byte index of the insertion cursor within /@text@/.
    -> m ()
iMContextSetSurrounding context text len cursorIndex = liftIO $ do
    context' <- unsafeManagedPtrCastPtr context
    text' <- textToCString text
    gtk_im_context_set_surrounding context' text' len cursorIndex
    touchManagedPtr context
    freeMem text'
    return ()

#if defined(ENABLE_OVERLOADING)
data IMContextSetSurroundingMethodInfo
instance (signature ~ (T.Text -> Int32 -> Int32 -> m ()), MonadIO m, IsIMContext a) => O.MethodInfo IMContextSetSurroundingMethodInfo a signature where
    overloadedMethod = iMContextSetSurrounding

#endif

-- method IMContext::set_use_preedit
-- method type : OrdinaryMethod
-- Args: [ Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "IMContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkIMContext" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "use_preedit"
--           , argType = TBasicType TBoolean
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "whether the IM context should use the preedit string."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "gtk_im_context_set_use_preedit" gtk_im_context_set_use_preedit :: 
    Ptr IMContext ->                        -- context : TInterface (Name {namespace = "Gtk", name = "IMContext"})
    CInt ->                                 -- use_preedit : TBasicType TBoolean
    IO ()

-- | Sets whether the IM context should use the preedit string
-- to display feedback. If /@usePreedit@/ is FALSE (default
-- is TRUE), then the IM context may use some other method to display
-- feedback, such as displaying it in a child of the root window.
iMContextSetUsePreedit ::
    (B.CallStack.HasCallStack, MonadIO m, IsIMContext a) =>
    a
    -- ^ /@context@/: a t'GI.Gtk.Objects.IMContext.IMContext'
    -> Bool
    -- ^ /@usePreedit@/: whether the IM context should use the preedit string.
    -> m ()
iMContextSetUsePreedit context usePreedit = liftIO $ do
    context' <- unsafeManagedPtrCastPtr context
    let usePreedit' = (fromIntegral . fromEnum) usePreedit
    gtk_im_context_set_use_preedit context' usePreedit'
    touchManagedPtr context
    return ()

#if defined(ENABLE_OVERLOADING)
data IMContextSetUsePreeditMethodInfo
instance (signature ~ (Bool -> m ()), MonadIO m, IsIMContext a) => O.MethodInfo IMContextSetUsePreeditMethodInfo a signature where
    overloadedMethod = iMContextSetUsePreedit

#endif


