{-# LANGUAGE RebindableSyntax #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE RankNTypes #-}


module Poker.Game where

import Prelude hiding ((>>=), (>>), return)

import Poker.Base hiding (players)
import Control.Monad.State
import Control.Monad.Indexed.State
import Control.Applicative
import Data.Maybe
import Data.Map (Map)
import System.Random
import System.IO.Unsafe
import qualified Data.Map as Map

type Name = String

data Initial
data PreFlop
data Flop
data Turn
data River

data Seat = Seat
            { _name :: Name
            , _holding :: Maybe Holding
            , _stack :: Double
            }

data Board a where
  RiverBoard :: Card -> Board Turn -> Board River
  NoBoard :: Board Initial

data GameState a = GameState
                 { _seats :: Map Position (Maybe Seat)
                 , _board :: [Card]
                 , _stakes :: Double
                 , _pot :: Double
                 , _street :: Board a
                 , _dealer :: [Card]
                 , _generator :: StdGen
                 }

emptyTable :: GameState Initial
emptyTable = GameState
                 { _seats = Map.fromList []
                 , _board = []
                 , _stakes = 0.25
                 , _pot = 0
                 , _street = Board 
                 , _dealer = []
                 , _generator = unsafePerformIO newStdGen
                 }



type Transition i o a = IxState (GameState i) (GameState o) a

type Game a = forall i. (Transition i i a)

getNumPlayers :: Game  Int
getNumPlayers = do
  res <- length . _seats <$> get
  return res

transitionStreet :: Transition Flop Turn ()
transitionStreet = dealBoard 1

dealBoard :: Int -> Game ()
dealBoard cardNum = do
  state <- get
  let currBoard = _board state
  let (board', dealer') = splitAt cardNum $ _dealer state
  put state{_board=currBoard++board',_dealer=dealer'}

sitPlayer :: Player -> Game ()
sitPlayer player = do
  state <- get
  let seats = _seats state
  let availablePositions = filter (flip Map.member seats) listPosition
  case availablePositions of
    [] -> error "Couldn't sit player - need to use ExceptT"
    (p:ps) -> do
      let seats' = Map.insert p seats
      put state{_seats=seats}

-- dealHands :: Game ()
-- dealHands = do
--   state <- get
--   let seatMap = _seats state
--   let seatMap = 
--   seats
